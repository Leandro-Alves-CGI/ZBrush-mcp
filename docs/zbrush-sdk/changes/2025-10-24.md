# Mudanças em 2025-10-24

## https://developers.maxon.net/docs/zbrush/py/
Arquivo: `/pages/developers-maxon-net-zbrush-python-api.md`

```diff
--- old
+++ new
@@ -0,0 +1,7 @@
+# ZBrush Python API
+
+Fonte: https://developers.maxon.net/docs/zbrush/py/
+
+---
+
+ZBrush Python API
```

## https://developers.maxon.net/docs/zbrush/py/2026_0_0/manuals/man_getting_started.html
Arquivo: `/pages/developers-maxon-net-getting-started-zbrush-python-sdk-2026-0-0-documentation.md`

```diff
--- old
+++ new
@@ -0,0 +1,205 @@
+# Getting Started — ZBrush Python SDK 2026.0.0 documentation
+
+Fonte: https://developers.maxon.net/docs/zbrush/py/2026_0_0/manuals/man_getting_started.html
+
+---
+
+Getting Started — ZBrush Python SDK 2026.0.0 documentation
+index
+next
+|
+previous
+|
+ZBrush Python SDK 2026.0.0 documentation
+»
+Getting Started
+Getting Started
+¶
+The ZBrush Python API provides a shallow programmatic interface into ZBrush, reflecting most of the ZScript API, while putting all the power of Python at your fingertips.
+Note
+ZBrush 2026.0.0 ships with Python 3.11.9.
+Python in ZBrush
+¶
+The main entry point to executing Python code in ZBrush is the
+ZScript
+palette, which also contains the
+Python Scripting
+subpalette. The Python console of ZBrush can be found at the bottom of the UI.
+Fig. I: Shown on the left is the
+ZScript
+palette, which contains the
+Python Scripting
+subpalette, as well as the
+Script Window Mode
+subpalette where you can enable the Python console output. The Python console is shown at the bottom of the ZBrush UI.
+¶
+Important menu items are:
+ZScript Palette
+: This palette contains the
+Python Scripting
+subpalette, which provides access to Python-specific commands and functionalities.
+Load
+: Loads a Python script file and executes it.
+Reload
+: Executes the last loaded Python script again.
+Clear Output
+: Clears the output in the Python console. Note that this won’t scroll the console back to the top. So, if you are scrolled very far down, you might not see the top of the console anymore before you scroll back up.
+Script Window Mode
+: This allows you to toggle between the default (‘Classic’) output mode and the ‘Python Output’ mode. Without changing the mode, you will not see any Python output in the console.
+Tutorial View
+: This contains the console of ZBrush and will contain any console output from Python scripts.
+Running Python Scripts
+¶
+working directory:
+from
+zbrush
+import
+commands
+as
+zbc
+import
+os
+print
+(
+f
+"
+{
+zbc
+.
+system_info
+()
+= }
+"
+)
+# print the working dir:
+print
+(
+f
+"
+{
+os
+.
+getcwd
+()
+= }
+"
+)
+with
+open
+(
+"system_info.txt"
+,
+"w"
+)
+as
+f
+:
+f
+.
+write
+(
+zbc
+.
+system_info
+())
+Besides the
+Load
+and
+Reload
+buttons in the
+Python Scripting
+subpalette, there exist two more ways to run Python scripts in ZBrush:
+Using the Python console: You can enter and execute Python commands interactively in the Python console at the bottom of the UI.
+Using the command line: You can run Python scripts from the command line by launching ZBrush with the script as an argument.
+ZBrush Python environment
+¶
+On startup, ZBrush looks for python scripts named
+init.py
+throughout its
+PYTHONPATH
+, it will execute all instances found.
+As a user, this allows you to have a personal
+init.py
+script, while having options for an asset, project or studio level ones in larger scale work environments.
+ZBrush will also execute all
+*.py
+files found in the directories defined by the
+ZBRUSH_PLUGIN_PATH
+environment variable.
+ZBrush Python Modules
+¶
+The following modules are part of the Python integration into ZBrush
+zbrush.commands
+this module ports the equally-named ZScript commands to python.
+zbrush.utils
+this module contains various utilities.
+Using external python libraries
+¶
+If you want to use python libraries external to ZBrush in your Python scripts, you will have to add them either to your PYTHONPATH environment variable before starting ZBrush, or add them to the system path by calling
+sys.path.append()
+from within your Python session.
+You can also add the call to
+sys.path.append()
+to an
+init.py
+script.
+Differences between ZScript and Python
+¶
+Unlike the ZScript integration, for Python there’s a single interpreter/session created on startup so all actions done during the session are cumulative.
+This removes the simplicity of simply “reloading” ZScripts to try out things during development, but it allows for far more complex setups.
+To better illustrate the “cumulative” nature of the session, imagine the following example:
+“Script A” defines a variable.
+“Script B” uses the variable defined by “Script A” to generate another output.
+UI Additions
+¶
+There is now a toggle that allows changing the previously-named “ZScript Tutorial Window” (bottom of the viewport section) to display python output, for this go to the ZScript menu and enable “Script Window Output > ZScript Output”.
+There is a new “Python” sub-palette in the ZScript palette that replicates the functionality of the equally-named buttons, but it’s intended for Python use.
+Launch Script & Batch
+¶
+Running scripts on startup that do some automated operations might be needed, for this you can use the launch argument
+-script
+followed by the python script to execute to get it to run the script as soon as ZBrush is launched.
+/path/to/your/ZBrush.exe
+-script
+/path/to/my_script.py
+If you want ZBrush to exit after running the script, you can use the regular python exit approach, like in the following example script:
+import
+sys
+import
+zbrush.commands
+as
+zcmds
+zcmds
+.
+MessageOK
+(
+"Hello from Python!"
+)
+sys
+.
+exit
+(
+0
+)
+The above script would start up ZBrush, show an alert message, and upon clicking “Ok” it would continue the execution of the script, exiting ZBrush.
+By default, if any error is found during the execution of the script, the error will be caught and displayed in the error log, ZBrush will remain open in the errored state, to get ZBrush to shut down with a process error code add the
+-batch
+argument e.g:
+/path/to/your/ZBrush.exe
+-batch
+-script
+/path/to/my_script.py
+All python output is always redirected to terminal if one is attached to the process, this can be useful specially in batch mode.
+Getting Started
+Python in ZBrush
+Running Python Scripts
+ZBrush Python environment
+ZBrush Python Modules
+Using external python libraries
+Differences between ZScript and Python
+UI Additions
+Launch Script & Batch
+©
+Maxon Computer GmbH
+-
+End User License Agreement
```

## https://developers.maxon.net/docs/zbrush/py/2026_0_0/manuals/index.html
Arquivo: `/pages/developers-maxon-net-manuals-zbrush-python-sdk-2026-0-0-documentation.md`

```diff
--- old
+++ new
@@ -0,0 +1,31 @@
+# Manuals — ZBrush Python SDK 2026.0.0 documentation
+
+Fonte: https://developers.maxon.net/docs/zbrush/py/2026_0_0/manuals/index.html
+
+---
+
+Manuals — ZBrush Python SDK 2026.0.0 documentation
+index
+next
+|
+previous
+|
+ZBrush Python SDK 2026.0.0 documentation
+»
+Manuals
+Manuals
+¶
+Lists the manuals available in the ZBrush Python SDK documentation.
+Getting Started
+Provides a starting point for new users to get acquainted with the ZBrush Python API.
+<no title>
+Explains the Python related UI functionalities of ZBrush.
+ZScript Migration Manual
+Provides guidance on migrating ZScript to Python, detailing differences and changes in the API.
+Gui Manual
+Explains GUI concepts in the ZBrush Python API.
+Manuals
+©
+Maxon Computer GmbH
+-
+End User License Agreement
```

## https://developers.maxon.net/docs/zbrush/py/2026_0_0/manuals/examples.html
Arquivo: `/pages/developers-maxon-net-code-examples-zbrush-python-sdk-2026-0-0-documentation.md`

```diff
--- old
+++ new
@@ -0,0 +1,7642 @@
+# Code Examples — ZBrush Python SDK 2026.0.0 documentation
+
+Fonte: https://developers.maxon.net/docs/zbrush/py/2026_0_0/manuals/examples.html
+
+---
+
+Code Examples — ZBrush Python SDK 2026.0.0 documentation
+index
+next
+|
+previous
+|
+ZBrush Python SDK 2026.0.0 documentation
+»
+Code Examples
+Code Examples
+¶
+All code examples can also be found on
+GitHub
+.
+Overview
+¶
+Filename
+Description
+gui_notebar.py
+Demonstrates how to show a progress indicator with a message when running a long task.
+gui_notes.py
+Demonstrates how to build and run a modal dialog (a note).
+gui_palette.py
+Demonstrates how to build and run a non-modal dialog (a pallette).
+lib_zb_math.py
+Contains a basic math library used by some of the modeling examples.
+mod_curve_lightning.py
+Demonstrates how to construct curves in a tool.
+mod_subtool_array.py
+Demonstrates how to construct an array of sub tools within a tool.
+mod_subtool_export.py
+Demonstrates how to batch export all subtools into a ZPR.
+mod_zsphere_biped.py
+WIP: Do not ship.
+sys_timeline_colors.py
+Demonstrates how to add and delete keyframes in the timeline of ZBrush.
+sys_timeline_turntable.py
+Demonstrates how to create a turntable animation for the current tool in ZBrush.
+Code Examples
+¶
+Gui
+¶
+gui_notebar.py
+¶
+1
+"""Demonstrates how to show a progress indicator with a message when running a long task.
+2
+"""
+3
+__author__
+=
+"Ferdinand Hoppe"
+4
+__date__
+=
+"13/08/2025"
+5
+__copyright__
+=
+"Maxon Computer"
+6
+7
+from
+zbrush
+import
+commands
+as
+zbc
+8
+import
+time
+9
+10
+def
+main
+()
+->
+None
+:
+11
+"""
+12
+"""
+13
+# A long-running task simulation, where we update the note bar text and progress periodically.
+14
+for
+i
+in
+range
+(
+1000
+):
+15
+p
+:
+float
+=
+i
+/
+1000.0
+16
+zbc
+.
+set_notebar_text
+(
+f
+"Script is calculating :
+{
+round
+(
+100
+*
+p
+,
+2
+)
+}
+%"
+,
+p
+)
+17
+time
+.
+sleep
+(
+0.0025
+)
+18
+19
+# Clear the bar once we are done, otherwise it will linger until something else overrides it.
+20
+zbc
+.
+set_notebar_text
+(
+""
+,
+0
+)
+21
+22
+if
+__name__
+==
+"__main__"
+:
+23
+main
+()
+Find this example on
+GitHub
+.
+gui_notes.py
+¶
+1
+"""Demonstrates how to build and run a modal dialog (a note).
+2
+3
+ZBrush uses two central UI paradigms: palettes and notes. Palettes are a non-modal form of UI, where
+4
+the user can interact with the interface without being forced to make a decision. Notes, on the other
+5
+hand, are modal dialogs that require user interaction before they can return to the main interface.
+6
+7
+This script implements a simple coffee maker interface. The user can select a coffee type which
+8
+changes the UI and then displays a message when the user finalizes the dialog.
+9
+10
+The script is a port of the original [ZCoffee Maker example](https://tinyurl.com/2vn64m6e)
+11
+for ZScript but has been adopted to Python.
+12
+"""
+13
+__author__
+=
+"Javier Edo, Ferdinand Hoppe"
+14
+__date__
+=
+"21/08/2025"
+15
+__copyright__
+=
+"Maxon Computer"
+16
+17
+import
+os
+18
+import
+zbrush.commands
+as
+zbc
+19
+20
+# Notes assign IDs to added elements in the order they were added. Showing a note will then
+21
+# return an integer signifying the action that occurred. We do not really NEED these, but symbols
+22
+# make code more readable.
+23
+ID_BTN_BG
+:
+int
+=
+1
+# The background image, we do not really need this since we disable the button.
+24
+ID_BTN_1
+:
+int
+=
+2
+# The five coffee buttons.
+25
+ID_BTN_2
+:
+int
+=
+3
+26
+ID_BTN_3
+:
+int
+=
+4
+27
+ID_BTN_4
+:
+int
+=
+5
+28
+ID_BTN_5
+:
+int
+=
+6
+29
+ID_BTN_CUP
+:
+int
+=
+7
+# The cup image button.
+30
+ID_BTN_CANCEL
+:
+int
+=
+8
+# The cancel button.
+31
+ID_BTN_SERVE
+:
+int
+=
+9
+# The serve button.
+32
+33
+# The types of messages which are emitted when the user made a choice.
+34
+MSG_ENJOY_COFFEE
+:
+str
+=
+"\Cc0c0c0Enjoy your \Cffa000
+{coffee_type}
+\Cc0c0c0 !
+\n
+"
+35
+MSG_NO_COFFEE
+:
+str
+=
+"\Cffa000
+\n
+What, no coffee?!
+\n
+"
+36
+37
+# The message sent by the dialog. We need this a bit weird construction with a global variable
+38
+# because we call #run_note inside #freeze, so we cannot use a return value directly.
+39
+MESSAGE
+:
+str
+=
+""
+40
+41
+def
+run_note
+()
+->
+str
+:
+42
+"""Runs the note interface for the coffee maker and returns a message when the user made a
+43
+choice.
+44
+"""
+45
+h_size
+:
+int
+=
+20
+# The horizontal size of a coffee button.
+46
+v_size
+:
+int
+=
+18
+# The vertical size of a coffee button.
+47
+v_pos
+:
+int
+=
+87
+# The vertical offset of a coffee button.
+48
+h_pos
+:
+int
+=
+23
+# The horizontal position of a coffee button.
+49
+space
+:
+int
+=
+12
+# The horizontal space between the coffee buttons.
+50
+51
+# The paths of the images used to display the coffee choices. Be careful with relative paths in
+52
+# ZBrush scripts. Unlike for a 'normal' CPython VM, we are not running the VM not for this script
+53
+# alone. Due to that the working directory is not the script directory but the directory of
+54
+# ZBrush. So, the relative path "images/expresso.jpg" would not point towards the directory next
+55
+# to this script but a directory of the same name in the directory of the ZBrush instance running
+56
+# this script. So, we must be verbose with our paths (or change the wd but that is not a good idea).
+57
+image_dir
+:
+str
+=
+os
+.
+path
+.
+join
+(
+os
+.
+path
+.
+dirname
+(
+__file__
+),
+"images"
+)
+58
+images
+:
+list
+[
+str
+]
+=
+[
+os
+.
+path
+.
+join
+(
+image_dir
+,
+"expresso.jpg"
+),
+59
+os
+.
+path
+.
+join
+(
+image_dir
+,
+"cappuccino.jpg"
+),
+60
+os
+.
+path
+.
+join
+(
+image_dir
+,
+"latte.jpg"
+),
+61
+os
+.
+path
+.
+join
+(
+image_dir
+,
+"mocha.jpg"
+),
+62
+os
+.
+path
+.
+join
+(
+image_dir
+,
+"flat white.jpg"
+)]
+63
+background_image
+:
+str
+=
+os
+.
+path
+.
+join
+(
+image_dir
+,
+"ZCoffeeBack.jpg"
+)
+64
+65
+# The currently selected coffee as an index out of the five buttons.
+66
+selected_coffee
+:
+int
+=
+0
+67
+68
+# Start a loop where we build, update, and poll the dialog over and over again. This is sort of
+69
+# the main loop of this dialog.
+70
+while
+True
+:
+71
+# Add a button filling the full canvas which we disable and give an icon. So, we repurpose
+72
+# a button to just display the background image.
+73
+zbc
+.
+add_note_button
+(
+name
+=
+""
+,
+74
+icon_path
+=
+background_image
+,
+75
+initially_pressed
+=
+False
+,
+76
+initially_disabled
+=
+True
+,
+77
+h_rel_position
+=
+1
+,
+78
+v_rel_position
+=
+305
+,
+79
+width
+=
+320.0
+)
+80
+81
+# Add the five buttons to select a coffee, we use the #selected_coffee to decide if the button
+82
+# should have an "x" as the label and if it is in a pressed stated.
+83
+for
+i
+in
+range
+(
+5
+):
+84
+label
+:
+str
+=
+"x"
+if
+i
+==
+selected_coffee
+else
+""
+85
+is_pressed
+:
+bool
+=
+i
+==
+selected_coffee
+86
+zbc
+.
+add_note_button
+(
+87
+name
+=
+label
+,
+88
+icon_path
+=
+""
+,
+89
+initially_pressed
+=
+is_pressed
+,
+90
+initially_disabled
+=
+False
+,
+91
+h_rel_position
+=
+h_pos
+,
+92
+v_rel_position
+=
+v_pos
++
+((
+v_size
++
+space
+)
+*
+i
+),
+93
+width
+=
+h_size
+,
+94
+height
+=
+v_size
+,
+95
+bg_color
+=-
+1
+,
+96
+text_color
+=
+0xffa000
+,
+# Direct hex color, alias for zbc.rgb(255, 160, 0)
+97
+)
+98
+99
+zbc
+.
+add_note_button
+(
+""
+,
+images
+[
+selected_coffee
+],
+False
+,
+True
+,
+149
+,
+135
+)
+100
+zbc
+.
+add_note_button
+(
+"Cancel"
+,
+""
+,
+False
+,
+False
+,
+170
+,
+260
+,
+100
+,
+25
+)
+101
+zbc
+.
+add_note_button
+(
+"Serve Now"
+,
+""
+,
+False
+,
+False
+,
+30
+,
+260
+,
+100
+,
+25
+,
+-
+1
+,
+0xffa000
+)
+102
+103
+# The trick is now to dummy open the note dialog to poll its interface state. #action
+104
+# will hold the value of the last interaction, since we are in a loop here, this can also
+105
+# happen when the #add_note_button above not really added a new button but just 'updated'
+106
+# one in an already long running note with which the user already interacted.
+107
+action
+:
+int
+=
+zbc
+.
+show_note
+(
+""
+)
+108
+global
+MESSAGE
+# Make the global MESSAGE variable writeable in this scope.
+109
+110
+# The user clicked the cancel button, we set the message.
+111
+if
+action
+==
+ID_BTN_CANCEL
+:
+112
+MESSAGE
+=
+MSG_NO_COFFEE
+113
+return
+114
+# The user clicked the serve button, we mangle the selected coffee image name to return a
+115
+# message with the name of the selected coffee. E.g., ".../expresso.jpg" -> "expresso"
+116
+elif
+action
+==
+ID_BTN_SERVE
+:
+117
+coffee
+:
+str
+=
+os
+.
+path
+.
+basename
+(
+images
+[
+selected_coffee
+])
+.
+rsplit
+(
+"."
+,
+1
+)[
+0
+]
+118
+MESSAGE
+=
+MSG_ENJOY_COFFEE
+.
+format
+(
+coffee_type
+=
+coffee
+)
+119
+return
+120
+# The user clicked one of the coffees, we update the selection. #action must be offset
+121
+# by the first button ID so that we end up with a selection in the range [0, 4] instead
+122
+# of the button ID range [2, 6].
+123
+if
+action
+in
+(
+ID_BTN_1
+,
+ID_BTN_2
+,
+ID_BTN_3
+,
+ID_BTN_4
+,
+ID_BTN_5
+):
+124
+selected_coffee
+=
+action
+-
+2
+125
+126
+def
+main
+()
+->
+None
+:
+127
+"""Executed when ZBrush runs this script.
+128
+"""
+129
+# Freeze the UI while the note interface is running and then display the returned global message.
+130
+zbc
+.
+freeze
+(
+run_note
+)
+131
+zbc
+.
+show_note
+(
+text
+=
+MESSAGE
+,
+item_path
+=
+""
+,
+display_duration
+=
+2.0
+,
+bg_color
+=
+zbc
+.
+rgb
+(
+125
+,
+125
+,
+125
+))
+132
+133
+134
+if
+__name__
+==
+"__main__"
+:
+135
+main
+()
+Find this example on
+GitHub
+.
+gui_palette.py
+¶
+1
+"""Demonstrates how to build and run a non-modal dialog (a pallette).
+2
+3
+ZBrush uses two central UI paradigms: palettes and notes. Palettes are a non-modal form of UI, where
+4
+the user can interact with the interface without being forced to make a decision. Notes, on the other
+5
+hand, are modal dialogs that require user interaction before they can return to the main interface.
+6
+7
+Palettes can be docked in the UI and contain sub-palettes and UI gadgets such as buttons, sliders,
+8
+and switches. This example builds a simple palette with buttons and a slider, demonstrating how to
+9
+use callbacks to react to interface events.
+10
+"""
+11
+__author__
+=
+"Ferdinand Hoppe"
+12
+__date__
+=
+"13/08/2025"
+13
+__copyright__
+=
+"Maxon Computer"
+14
+15
+from
+zbrush
+import
+commands
+as
+zbc
+16
+17
+def
+on_click
+(
+sender
+:
+str
+)
+->
+None
+:
+18
+"""Callback function that is called when a button is clicked.
+19
+20
+We could write multiple callback functions for multiple buttons, but #sender allows us to
+21
+identify which button was clicked, so we can handle multiple buttons with a single function.
+22
+"""
+23
+if
+sender
+.
+endswith
+(
+"Button A"
+):
+24
+print
+(
+"Button A clicked"
+)
+25
+elif
+sender
+.
+endswith
+(
+"Button B"
+):
+26
+print
+(
+"Button B clicked"
+)
+27
+28
+# At any time we can poll the UI with #get.
+29
+print
+(
+f
+"Current value of Slider A:
+{
+zbc
+.
+get
+(
+'xPalette:Subpalette (Togglable):Slider A'
+)
+}
+"
+)
+30
+print
+(
+f
+"Current value of Switch A:
+{
+zbc
+.
+get
+(
+'xPalette:Subpalette (Togglable):Switch A'
+)
+}
+"
+)
+31
+32
+def
+on_value_change
+(
+sender
+:
+str
+,
+value
+:
+float
+)
+->
+None
+:
+33
+"""Callback function that is called when a slider or other value-changing element is changed.
+34
+"""
+35
+if
+sender
+.
+endswith
+(
+"Slider A"
+):
+36
+print
+(
+f
+"Slider A value changed to
+{
+value
+}
+"
+)
+37
+elif
+sender
+.
+endswith
+(
+"Switch A"
+):
+38
+print
+(
+f
+"Switch A toggled to
+{
+bool
+(
+value
+)
+}
+"
+)
+39
+40
+def
+main
+()
+->
+None
+:
+41
+"""Executed when ZBrush runs this script.
+42
+"""
+43
+# If there is already a palette named "MyPalette", close it, so that we always start from scratch.
+44
+palette
+:
+str
+=
+"MyPalette"
+45
+if
+zbc
+.
+exists
+(
+palette
+):
+46
+zbc
+.
+close
+(
+palette
+)
+47
+48
+# Add a new palette named "MyPalette" to the ZBrush interface which will auto dock to the right.
+49
+# Then add a subpalette named "Subpalette" to the "MyPalette" palette which has no title bar and
+50
+# is always open.
+51
+zbc
+.
+add_palette
+(
+palette
+,
+docking_bar
+=
+1
+)
+52
+subpalette
+:
+str
+=
+f
+"
+{
+palette
+}
+:Subpalette"
+53
+zbc
+.
+add_subpalette
+(
+subpalette
+,
+title_mode
+=
+2
+)
+54
+55
+# Adds two buttons to the "Subpalette" subpalette. Instead of a an explicit callback function,
+56
+# we can also use a lambda function. In fact any callable will work. It also important to
+57
+# understand the unit system of interface gadgets.
+58
+59
+# Two buttons which use the #on-click callback and which have an automatic width (0, the default).
+60
+zbc
+.
+add_button
+(
+f
+"
+{
+subpalette
+}
+:Button A"
+,
+"Button A Tooltip!"
+,
+on_click
+,
+width
+=
+0
+)
+61
+zbc
+.
+add_button
+(
+f
+"
+{
+subpalette
+}
+:Button B"
+,
+"Button B Tooltip!"
+,
+on_click
+,
+width
+=
+0
+)
+62
+# Two buttons which use a lambda function as the callback and which have a relative width in the
+63
+# the interval |0, 1]. Since both occupy 100%, they will be each placed in one line.
+64
+zbc
+.
+add_button
+(
+f
+"
+{
+subpalette
+}
+:Button C"
+,
+""
+,
+lambda
+item
+:
+print
+(
+f
+"
+{
+item
+}
+pressed"
+),
+width
+=
+1.0
+)
+65
+zbc
+.
+add_button
+(
+f
+"
+{
+subpalette
+}
+:Button D"
+,
+""
+,
+lambda
+item
+:
+print
+(
+f
+"
+{
+item
+}
+pressed"
+),
+width
+=
+1.0
+)
+66
+# And finally a button with a fixed width in pixels. WARNING: When your gadget is larger than
+67
+# the available space, it may not be displayed correctly.
+68
+zbc
+.
+add_button
+(
+f
+"
+{
+subpalette
+}
+:Button E"
+,
+""
+,
+on_click
+,
+width
+=
+100
+)
+69
+70
+# ----------------------------------------------------------------------------------------------
+71
+72
+# Adds a subpalette named "Subpalette (Foldable)" to the "Palette" palette which has a title bar
+73
+# and a minimize button, and is foldable.
+74
+subpalette_foldable
+:
+str
+=
+f
+"
+{
+palette
+}
+:Subpalette (Foldable)"
+75
+zbc
+.
+add_subpalette
+(
+subpalette_foldable
+)
+76
+77
+# Adds a slider and a switch to the "Subpalette (Foldable)" subpalette.
+78
+zbc
+.
+add_slider
+(
+f
+"
+{
+subpalette_foldable
+}
+:Slider A"
+,
+2
+,
+1
+,
+0
+,
+10
+,
+"Some help text."
+,
+79
+on_value_change
+,
+width
+=
+200
+)
+80
+zbc
+.
+add_switch
+(
+f
+"
+{
+subpalette_foldable
+}
+:Switch A"
+,
+True
+,
+"Some help text."
+,
+on_value_change
+)
+81
+82
+# Retroactively change the min/max values of the slider from 0-10 to 5-15.
+83
+zbc
+.
+set_min
+(
+f
+"
+{
+subpalette_foldable
+}
+:Slider A"
+,
+5
+)
+84
+zbc
+.
+set_max
+(
+f
+"
+{
+subpalette_foldable
+}
+:Slider A"
+,
+15
+)
+85
+86
+# Set the value of an interface element. We can use it both the set numeric values and booleans
+87
+# such as a toggle.
+88
+zbc
+.
+set
+(
+f
+"
+{
+subpalette_foldable
+}
+:Slider"
+,
+7
+)
+89
+zbc
+.
+set
+(
+f
+"
+{
+subpalette_foldable
+}
+:Switch"
+,
+True
+)
+90
+91
+# And finally unfold our palette, if we would not do this, it would start our in a folded state.
+92
+zbc
+.
+maximize
+(
+subpalette_foldable
+)
+93
+94
+# Other than for modal notes, there is no main loop or manual polling required. Our UI will work
+95
+# via the callbacks defined above. But at any point, one of the call backs could call this
+96
+# function again to rebuild the UI.
+97
+98
+if
+__name__
+==
+"__main__"
+:
+99
+main
+()
+Find this example on
+GitHub
+.
+Modeling
+¶
+lib_zb_math.py
+¶
+1
+"""Contains a basic math library used by some of the modeling examples.
+2
+3
+This file does not contain any ZBrush specific functionality. THIS IS STILL A CODE EXAMPLE AND NOT
+4
+A FEATURE. We cannot debug or extend this library. But it can be starting point for you to fill some
+5
+gaps in ZBrush's current API.
+6
+7
+Functions:
+8
+9
+interpolate:    Linearly interpolates between two values.
+10
+11
+Classes:
+12
+13
+Vector:         Represents a three component vector type and provides basic vector operations.
+14
+ValueNoise:     Realizes a naive value noise.
+15
+16
+"""
+17
+__author__
+=
+"Ferdinand Hoppe"
+18
+__date__
+=
+"22/08/2025"
+19
+__copyright__
+=
+"Maxon Computer"
+20
+21
+import
+math
+22
+import
+typing
+23
+24
+def
+interpolate
+(
+a
+:
+float
+,
+b
+:
+float
+,
+t
+:
+float
+)
+->
+float
+:
+25
+"""Linearly interpolates between #a and #b using #t.
+26
+"""
+27
+return
+a
++
+t
+*
+(
+b
+-
+a
+)
+28
+29
+class
+Vector
+:
+30
+"""Represents a three component vector type and provides basic vector operations.
+31
+"""
+32
+def
+__init__
+(
+self
+,
+x
+:
+float
+=
+0.0
+,
+y
+:
+float
+=
+0.0
+,
+z
+:
+float
+=
+0.0
+)
+->
+None
+:
+33
+"""Constructs a vector.
+34
+"""
+35
+self
+.
+x
+=
+x
+;
+self
+.
+y
+=
+y
+;
+self
+.
+z
+=
+z
+36
+37
+def
+__add__
+(
+self
+,
+other
+:
+"Vector"
+)
+->
+"Vector"
+:
+38
+"""Adds #other to #self and returns the result.
+39
+"""
+40
+return
+Vector
+(
+self
+.
+x
++
+other
+.
+x
+,
+self
+.
+y
++
+other
+.
+y
+,
+self
+.
+z
++
+other
+.
+z
+)
+41
+42
+def
+__iadd__
+(
+self
+,
+other
+:
+"Vector"
+)
+->
+"Vector"
+:
+43
+"""Adds #other to #self.
+44
+"""
+45
+self
+.
+x
++=
+other
+.
+x
+;
+self
+.
+y
++=
+other
+.
+y
+;
+self
+.
+z
++=
+other
+.
+z
+46
+return
+self
+47
+48
+def
+__sub__
+(
+self
+,
+other
+:
+"Vector"
+)
+->
+"Vector"
+:
+49
+"""Subtracts #other from #self and returns the result.
+50
+"""
+51
+return
+Vector
+(
+self
+.
+x
+-
+other
+.
+x
+,
+self
+.
+y
+-
+other
+.
+y
+,
+self
+.
+z
+-
+other
+.
+z
+)
+52
+53
+def
+__isub__
+(
+self
+,
+other
+:
+"Vector"
+)
+->
+"Vector"
+:
+54
+"""Subtracts #other from #self.
+55
+"""
+56
+self
+.
+x
+-=
+other
+.
+x
+;
+self
+.
+y
+-=
+other
+.
+y
+;
+self
+.
+z
+-=
+other
+.
+z
+57
+return
+self
+58
+59
+def
+__mul__
+(
+self
+,
+other
+:
+float
+)
+->
+"Vector"
+:
+60
+"""Multiplies #self by the scalar #other and returns the result.
+61
+"""
+62
+return
+Vector
+(
+self
+.
+x
+*
+other
+,
+self
+.
+y
+*
+other
+,
+self
+.
+z
+*
+other
+)
+63
+64
+def
+__rmul__
+(
+self
+,
+other
+:
+float
+)
+->
+"Vector"
+:
+65
+"""Multiplies a scalar by #self and returns the result.
+66
+"""
+67
+return
+self
+*
+other
+68
+69
+def
+__imul__
+(
+self
+,
+other
+:
+float
+)
+->
+"Vector"
+:
+70
+"""Multiplies #self by the scalar #other.
+71
+"""
+72
+self
+.
+x
+*=
+other
+;
+self
+.
+y
+*=
+other
+;
+self
+.
+z
+*=
+other
+73
+return
+self
+74
+75
+def
+__iter__
+(
+self
+)
+->
+typing
+.
+Iterator
+[
+float
+]:
+76
+"""Iterates over the components of the vector.
+77
+"""
+78
+yield
+self
+.
+x
+79
+yield
+self
+.
+y
+80
+yield
+self
+.
+z
+81
+82
+def
+__repr__
+(
+self
+)
+->
+str
+:
+83
+"""Returns a string representation of the vector.
+84
+"""
+85
+return
+(
+f
+"
+{
+self
+.
+__class__
+.
+__name__
+}
+(
+{
+round
+(
+self
+.
+x
+,
+3
+)
+}
+,
+{
+round
+(
+self
+.
+y
+,
+3
+)
+}
+, "
+86
+f
+"
+{
+round
+(
+self
+.
+z
+,
+3
+)
+}
+)"
+)
+87
+88
+def
+dot
+(
+self
+,
+other
+:
+"Vector"
+)
+->
+float
+:
+89
+"""Returns the dot product of #self and #other.
+90
+"""
+91
+return
+self
+.
+x
+*
+other
+.
+x
++
+self
+.
+y
+*
+other
+.
+y
++
+self
+.
+z
+*
+other
+.
+z
```

## https://developers.maxon.net/docs/zbrush/goz_sdk.pdf
Arquivo: `/pages/developers-maxon-net-documento-pdf.md`

```diff
--- old
+++ new
@@ -0,0 +1,7 @@
+# Documento PDF
+
+Fonte (PDF): https://developers.maxon.net/docs/zbrush/goz_sdk.pdf
+
+---
+
+Este item é um PDF. Acesse o link acima para visualizar.
```
